import { SearchQueryType, Track, BaseExtractor, ExtractorStreamable, ExtractorSearchContext, ExtractorInfo, Playlist, GuildQueueHistory } from 'discord-player';
import Innertube, { OAuth2Tokens } from 'youtubei.js';
import { InnerTubeClient, DownloadOptions, InnerTubeConfig, FormatOptions } from 'youtubei.js/dist/src/types';
import { Readable } from 'node:stream';
import { Video } from 'youtubei.js/dist/src/parser/nodes';
import { AsyncLocalStorage } from 'node:async_hooks';
import { PoTokenResult } from 'bgutils-js';
import * as youtubei_js_agnostic from 'youtubei.js/agnostic';
import { VideoInfo } from 'youtubei.js/dist/src/parser/youtube';
import { YTNode } from 'youtubei.js/dist/src/parser/helpers';
import * as youtubei_js_dist_src_parser_misc from 'youtubei.js/dist/src/parser/misc';
import { Author } from 'youtubei.js/dist/src/parser/misc';
import { ChatAction } from 'youtubei.js/dist/src/parser/youtube/LiveChat';
import { PassThrough } from 'stream';

interface StreamOptions {
    useClient?: InnerTubeClient;
    highWaterMark?: number;
}
interface RefreshInnertubeOptions {
    filePath: string;
    interval?: number;
}
type TrustedTokenConfig = {
    poToken: string;
    visitorData: string;
};
type QueryBridgeModes = Partial<Record<SearchQueryType, "yt" | "ytmusic">> & {
    default?: "yt" | "ytmusic";
};
interface YoutubeiOptions {
    authentication?: string;
    overrideDownloadOptions?: DownloadOptions;
    createStream?: (q: Track, extractor: BaseExtractor<object>) => Promise<string | Readable>;
    signOutOnDeactive?: boolean;
    streamOptions?: StreamOptions;
    overrideBridgeMode?: "ytmusic" | "yt" | QueryBridgeModes;
    disablePlayer?: boolean;
    ignoreSignInErrors?: boolean;
    innertubeConfigRaw?: InnerTubeConfig;
    trustedTokens?: TrustedTokenConfig;
    cookie?: string;
}
interface AsyncTrackingContext {
    useClient: InnerTubeClient;
    highWaterMark?: number;
}
declare class YoutubeiExtractor extends BaseExtractor<YoutubeiOptions> {
    #private;
    static identifier: string;
    innerTube: Innertube;
    _stream: (q: Track, extractor: BaseExtractor<object>) => Promise<ExtractorStreamable>;
    static instance?: YoutubeiExtractor;
    priority: number;
    static ytContext: AsyncLocalStorage<AsyncTrackingContext>;
    setInnertube(tube: Innertube): void;
    setPoToken(token: PoTokenResult, visitorData: string): Promise<void>;
    static getInstance(): YoutubeiExtractor | undefined;
    setClientMode(client: InnerTubeClient): void;
    static getStreamingContext(): AsyncTrackingContext;
    activate(): Promise<void>;
    signIn(tokens: string): Promise<void>;
    deactivate(): Promise<void>;
    validate(query: string, type?: SearchQueryType | null | undefined): Promise<boolean>;
    bridge(track: Track, ext: BaseExtractor | null): Promise<ExtractorStreamable | null>;
    bridgeFromYTMusic(query: string, track: Track): Promise<ExtractorStreamable | null>;
    bridgeFromYT(query: string, track: Track): Promise<ExtractorStreamable | null>;
    handle(query: string, context: ExtractorSearchContext): Promise<ExtractorInfo>;
    buildTrack(vid: Video, context: ExtractorSearchContext, pl?: Playlist): Track<any>;
    stream(info: Track<unknown>): Promise<ExtractorStreamable>;
    getRelatedTracks(track: Track<{
        duration_ms: number;
        live: boolean;
    }>, history: GuildQueueHistory<unknown>): Promise<ExtractorInfo>;
}

declare function objectToToken(tokens: OAuth2Tokens): string;
declare function tokenToObject(token: string): OAuth2Tokens;

declare function getYoutubeiInstance(): youtubei_js_agnostic.Innertube | undefined;

declare class LiveChatAuthor {
    username: string;
    url: string;
    thumbnail: string;
    verifiedChannel: boolean;
    verifiedArtist: boolean;
    isMod: boolean;
    id: string;
    raw: Author;
    constructor(author: Author);
}

declare enum ChatMessageType {
    Regular = 1,
    Premium = 2,
    PremiumSticker = 3
}
declare class LiveChatMessage {
    author: LiveChatAuthor;
    type: ChatMessageType;
    content?: string;
    timestamp: number;
    constructor(chatUpdate: YTNode, type: ChatMessageType);
}

type LiveChatReturnType = ReturnType<(typeof VideoInfo)["prototype"]["getLiveChat"]>;
declare const LiveChatEvents: {
    readonly MessageCreate: "messageCreate";
    readonly StreamEnd: "streamEnd";
};
type LiveChatEvents = (typeof LiveChatEvents)[keyof typeof LiveChatEvents];
interface LiveChatEventsData {
    [LiveChatEvents.MessageCreate]: (message: LiveChatMessage) => any;
    [LiveChatEvents.StreamEnd]: () => any;
}
declare class LiveChat {
    #private;
    chat: ReturnType<(typeof VideoInfo)["prototype"]["getLiveChat"]>;
    chatUpdateHandler: (action: ChatAction) => void;
    constructor(chat: LiveChatReturnType);
    on<T extends LiveChatEvents>(event: T, handler: LiveChatEventsData[T]): void;
    destroy(): void;
}

declare function getLiveChat(videoUrl: string, ext?: YoutubeiExtractor): Promise<LiveChat | null>;

type If<C, T, F> = C extends true ? T : F;
declare const Errors: {
    readonly InvalidURL: Error;
    readonly InvalidYTURL: Error;
    readonly NoDownload: Error;
};
declare function validateURL(url: string): false | URL;
declare function stream<T extends boolean = false>(url: string, skipStream?: T, options?: FormatOptions, tube?: Innertube): Promise<{
    basicInfo: {
        like_count: number | undefined;
        is_liked: boolean | undefined;
        is_disliked: boolean | undefined;
        embed: {
            iframe_url: string;
            flash_url: string;
            flash_secure_url: string;
            width: any;
            height: any;
        } | null | undefined;
        channel: {
            id: string;
            name: string;
            url: string;
        } | null;
        is_unlisted: boolean | undefined;
        is_family_safe: boolean | undefined;
        category: string | null;
        has_ypc_metadata: boolean | null;
        start_timestamp: Date | null;
        end_timestamp: Date | null;
        view_count: number | undefined;
        url_canonical: string | null;
        tags: string[] | null;
        id?: string | undefined;
        channel_id?: string | undefined;
        title?: string | undefined;
        duration?: number | undefined;
        keywords?: string[] | undefined;
        is_owner_viewing?: boolean | undefined;
        short_description?: string | undefined;
        thumbnail?: youtubei_js_dist_src_parser_misc.Thumbnail[] | undefined;
        allow_ratings?: boolean | undefined;
        author?: string | undefined;
        is_private?: boolean | undefined;
        is_live?: boolean | undefined;
        is_live_content?: boolean | undefined;
        is_live_dvr_enabled?: boolean | undefined;
        is_upcoming?: boolean | undefined;
        is_crawlable?: boolean | undefined;
        is_post_live_dvr?: boolean | undefined;
        is_low_latency_live_stream?: boolean | undefined;
        live_chunk_readahead?: number | undefined;
    };
    formatInfo: youtubei_js_dist_src_parser_misc.Format;
    stream: If<T, null, PassThrough>;
    downloadedUrl: string;
}>;

declare function generateOauthTokens(): Promise<void>;

export { type AsyncTrackingContext, ChatMessageType, Errors, type If, LiveChatEvents, type QueryBridgeModes, type RefreshInnertubeOptions, type StreamOptions, type TrustedTokenConfig, YoutubeiExtractor, type YoutubeiOptions, generateOauthTokens, getLiveChat, getYoutubeiInstance, objectToToken, stream, tokenToObject, validateURL };
